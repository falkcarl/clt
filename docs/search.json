[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Central Limit Theorem",
    "section": "",
    "text": "#| '!! shinylive warning !!': |\n#|   shinylive does not work in self-contained HTML documents.\n#|   Please set `embed-resources: false` in your metadata.\n#| standalone: true\n#| viewerHeight: 1200\n\n######################################################################\n## Interactive Statistics Project - Module 1: Central Limit Theorem\n##\n## We thank the Association for Psychological Science for a small\n## teaching grant to help in the development of this software.\n##\n## Copyright 2025-2026 Jeremy Rappel, Carl F. Falk, Mira Saad &\n##  Jens Kreitewolf\n##\n## This program is free software: you can redistribute it and/or\n## modify it under the terms of the GNU Affero General Public License as\n## published by the Free Software Foundation, either version 3 of\n## the License, or (at your option) any later version.\n##\n## This program is distributed in the hope that it will be useful,\n## but WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n## GNU Affero General Public License for more details.\n## &lt;http://www.gnu.org/licenses/&gt;\n##\n\n\nlibrary(tibble) # CFF: this one also apparently required for shinylive to work\nlibrary(shiny)\nlibrary(munsell) # was included due to bug in getting ggplot2 to work with shinylive; still required for some reason\nlibrary(bslib) # For bootstrap UIs\nlibrary(bsicons) # for tooltip icons\nlibrary(ggplot2) #include.only = c(\"select\", \"mutate\"))\n\n\ninfopop &lt;- tooltip(\n  bs_icon(\"info-circle\"),\n  \"This is the distribution of all scores in the population.\",\n  placement=\"right\"\n)\n\n\ninfosamp &lt;- tooltip(\n  bs_icon(\"info-circle\"),\n  \"These are the scores from a single sample from the population. Every dot corresponds to one observation.\",\n  placement=\"right\"\n)\n\ninfosampdist &lt;- tooltip(\n  bs_icon(\"info-circle\"),\n  \"Every time we draw a sample, the mean of that sample counts as one observation in the sampling distribution.\",\n  placement=\"right\"\n)\n\n# CFF population distribution options\npopopts &lt;- popover(\n  bs_icon(\"gear\"),  # Gear icon\n  selectInput(\n    \"distType\", \"Distribution Type\", c(\"Uniform\",\"Normal\",\"Chi-Squared\"),\n    selected = \"Normal\"\n  ),\n  conditionalPanel(\n    condition = \"input.distType == 'Normal'\", #This is javascript, thus the . notation\n    sliderInput(\"mean\", \"Î¼\", min = 1, max = 10, value = 5, step=1),\n    sliderInput(\"sd\", \"SD\", min = 1, max = 10, value = 1, step=1)\n  ), #end conditionalPanel()\n  \n  conditionalPanel(\n    condition = \"input.distType == 'Uniform'\",\n    sliderInput(\"min_limit\", \"Minimum\", min = 1, max = 10, value = 1, step=1), \n    sliderInput(\"max_limit\", \"Maximum\", min = 1, max = 10, value = 5, step=1)\n  ), #end conditionalPanel()\n  conditionalPanel(\n    condition = \"input.distType == 'Chi-Squared'\",\n    sliderInput(\"df\", \"Degrees of Freedom\", min = 1, max = 10, value = 5, step=1)\n  ), #end conditionalPanel()\n  checkboxInput(\n    \"yaxis\", \"Toggle Y-Axis\"\n  ),\n  placement=\"right\"\n)\n\n#Extra settings (skewness, kurtosis) for sampling distribution pllot\npopopts_samplingdist &lt;- popover(\n  bs_icon(\"gear\"),  # Gear icon\n  checkboxInput(\"overlay\", \"Toggle Normal Overlay\"),  \n  checkboxInput(\n    \"skew\", \"Skewness & Kurtosis\"\n  ),  \n  sliderInput(\"bins\",\n              \"Number of bins for histogram:\",\n              min = 30,\n              max = 200,\n              value = 75),\n  placement=\"right\"\n)\n\npopopts_samplingplot&lt;- popover(\n  bs_icon(\"gear\"),  # Gear icon\n  checkboxInput(\n    \"se\", \"Estimated Standard Error\"\n  ),\n  actionButton(\"prevSamp\",\"Previous Sample\"), actionButton(\"nextSamp\",\"Next Sample\"),\n  placement=\"right\"\n)\n\n#instead of a bloated ui object, here we're creating a list of each card to inject later\ncards &lt;- list(\n  navset_card_underline(\n    title = card_header(\"Population Distribution\", infopop, popopts),\n    full_screen=TRUE,    \n    height=850,\n    nav_panel(\"Graph\",\n      plotOutput(\"popPlot\")#,\n      #min_height=250\n    )\n  ),\n  navset_card_underline(\n    title= card_header(\"Sample Values\",infosamp, popopts_samplingplot), \n    full_screen=T,\n    height=850, #JR: Fixing this to minimize the plots looking squished; may need a more dynamic solution\n    nav_panel(\"Graph\", plotOutput(\"sampleValues\")),\n    nav_panel(\"Table\", tableOutput(\"sampleTable\")),\n    selected = \"Graph\"\n  ),\n  navset_card_underline(\n    title= card_header(\"Sampling Distribution\",infosampdist,popopts_samplingdist), \n    full_screen=T,\n    height=850, #JR: Fixing this to minimize the plots looking squished; may need a more dynamic solution\n    nav_panel(\"Graph\", plotOutput(\"sampPlot\")),\n    nav_panel(\"Table\", tableOutput(\"sampleValuesTable\")),\n    selected = \"Graph\"\n  )\n)\n\n# Define UI for application that draws a histogram\nui &lt;- page_sidebar(\n  #Creates a sidebar containing option toggles\n  title = div(h5('Sampling and Sampling Distributions', style=\"margin: 0;\"), h6('The Central Limit Theorem', style=\"margin: 0;\")),\n  theme = bs_theme(version=5, preset=\"lumen\"),\n  sidebar = sidebar(\n    fluidRow(actionButton(\"plus1\", \"+1 sample\"),\n             actionButton(\"plus5\", \"+5 samples\"),\n             actionButton(\"plus1000\", \"+ 1000 samples\")\n             ),\n    fluidRow(actionButton(\"reset\",\"Reset\"),\n             sliderInput(\"sampSize\", \"Observations per Sample:\", min=1, max=100, value=30, step=1)), #JR: Added button to reset the app\n  ),\n  layout_columns(\n    col_widths = c(-1, 7, -1),\n    cards[[1]]#, #JR: The population distribution\n  ),\n  layout_columns(\n    col_widths = c(-1, 7, -1),\n    cards[[2]]), #JR: The sample distribution\n  layout_columns(\n    col_widths = c(-1, 7, -1),\n    cards[[3]]) #JR: The sampling distribution\n  #layout_columns(col_widths = c(-2, 8),)) #JR: Combined sample table and graph\n)\n\n# Define server logic required to draw a histogram\nserver &lt;- function(input, output, session) { # JR: Added \"session\" to get the reset button to work; also necessary if we add introJS functionality\n  observeEvent(input$reset,\n               {session$reload()}) #JR: Restarts the session if user presses the \"Reset\" button\n\n    #################################\n   # Population Distribution Values#\n  #################################\n  mu &lt;- reactive({as.numeric(input$mean)}) #Remember, these values are stored as functions\n  stdev &lt;- reactive({input$sd})\n  min &lt;- reactive({as.numeric(input$min_limit)})\n  max &lt;- reactive({as.numeric(input$max_limit)})\n  distType &lt;- reactive({input$distType})\n  df &lt;- reactive({as.numeric(input$df)}) #JR: Updated to make sure it's a numeric value\n  \n  \n    #############################\n   # Sample Distribution Values#\n  #############################\n  N &lt;- 10000 # CFF hardcoded total number of possible samples\n  obs &lt;- reactive({input$sampSize})\n  se &lt;- reactive({stdev()/sqrt(obs())}) # CFF - do we use this ever?\n  \n  whichsamp &lt;- reactiveValues(i = 0)\n  index &lt;- reactiveValues(i=0)\n\n  #JR: Moved these from the Population Plot object so we can access the same values for the sample plot\n  #FIXME: Looks kinda weird with for the Chi-Squared distribution\n  lower &lt;- reactive({switch(distType(),\n                  \"Normal\" =mu()-3*stdev(),\n                  \"Chi-Squared\" =0,\n                  \"Uniform\" = min())})\n  upper &lt;- reactive({switch(distType(),\n                  \"Normal\" =mu()+3*stdev(),\n                  \"Chi-Squared\" =(df()*2)+5, #JR: Stand-in, should be updated to something more dynamic/sensible\n                  \"Uniform\" = max())})#The lower bound of the chart; if H1 &gt; H0, then -3 is the floor, otherwise the floor is 3SD below the H1 distribution\n  \n    ##########################\n   # Generating Sample Data #\n  ##########################\n  datasets &lt;- reactive({\n    whichsamp$i &lt;- 0\n    index$i &lt;- 0\n    dat &lt;- matrix(nrow=N,ncol=obs())\n    nobs &lt;- obs()\n    for(i in 1:N){\n        if(distType()==\"Normal\"){\n          dat[i,] &lt;- rnorm(obs(), mean=mu(),sd=stdev()) \n        } else if (distType()==\"Uniform\"){\n          dat[i,] &lt;- runif(obs(), min=min(), max = max())\n        } else if (distType()==\"Chi-Squared\"){\n          dat[i,] &lt;- rchisq(obs(), df=df())      \n        }\n    }\n    return(list(dat = dat, Nsamp = N, nobs=nobs))\n  })\n  \n  observeEvent(input$plus1, { #Updates the sample size value when the relevant button is clicked\n    if ((whichsamp$i + 1)&lt;10000) { #JR: Unsure if these are the most efficient way to avoid out-of-bounds erros\n    whichsamp$i &lt;- whichsamp$i + 1\n    } else {whichsamp$i = 10000}\n  })\n  observeEvent(input$plus5, {\n    if ((whichsamp$i+ 5) &lt; 10000) {\n      whichsamp$i &lt;- whichsamp$i + 5\n    } else {whichsamp$i = 10000}\n  })\n  observeEvent(input$plus1000, {\n    if ((whichsamp$i + 1000) &lt; 10000) {\n      whichsamp$i &lt;- whichsamp$i + 1000\n    } else {whichsamp$i = 10000}\n  })\n  \n #JR: This section updates the display of the sample values when using the \"Previous/Next Sample Buttons\"\n #It works by updating the \"index\" reactive value, which is subtracted from the current sample to move things about\n  observeEvent(input$nextSamp, {\n    if ((whichsamp$i-index$i) &lt; whichsamp$i) {\n    index$i &lt;- index$i-1\n  }})\n  \n  observeEvent(input$prevSamp, {\n    if (whichsamp$i - index$i &gt; 1) {\n    index$i &lt;- index$i+1\n    }})\n  \n  ## Population plot\n  output$popPlot &lt;- renderPlot({\n\n    popplt &lt;- ggplot(data=data.frame(x=c(lower(),upper())),aes(x)) +\n      #The true population distribution\n      switch(input$distType,\n             \"Uniform\" = stat_function(fun=dunif,args=list(min=lower(),max=upper()),geom=\"line\", linetype=\"dotted\", color=\"red\",xlim=c(lower(),upper())),\n             \"Normal\" = stat_function(fun=dnorm,args=list(mean=mu(), sd=stdev()),geom=\"area\", linetype=\"dotted\",fill=NA, color=\"red\",xlim=c(lower(),upper())),\n             \"Chi-Squared\" = stat_function(fun=dchisq,args=list(df=df()),geom=\"area\", linetype=\"dotted\",fill=NA, color=\"red\",xlim=c(lower(),upper()))) +\n      #Clears the y-axis label\n      ylab(\"\")+\n      #Sets the x axis ticks to cover the whole plot\n      scale_x_continuous(limits=c(lower(),upper()),breaks= seq(round(lower()),round(upper()))) +\n      #Clears the y-axis ticks\n      #scale_y_continuous(breaks=NULL) +\n      theme_classic() +\n      annotate(\"text\",x=Inf,y=Inf, label = \n        switch(\n          input$distType,\n          \"Normal\" = paste0(\"Population Mean = \",mu()),\n          \"Uniform\" = paste0(\"Population Maximum = \",max()),\n          \"Chi-Squared\" = paste0(\"Degrees of Freedom = \",df()) #JR: Added these annotations to reflect info relevant to a particular distribution; may require some re-thinking though to tie in w/ sampling distribution means\n      ), vjust = 1, hjust = 1)+ # JR: End first annotate()\n      annotate(\"text\",x=Inf,y=Inf, label = \n          switch(input$distType,\n                 \"Normal\" = paste0(\"Population SD = \",stdev()),\n                 \"Uniform\" = paste0(\"Population Minimum = \",min()),\n                 \"Chi-Squared\" = paste0(\"\")\n                        ), vjust = 3, hjust = 1) # JR: End second annotate()\n    \n    if (input$yaxis == FALSE){\n      popplt &lt;- popplt + scale_y_continuous(breaks=NULL)\n    } \n    \n    popplt\n      \n  }) #end output$popPlot\n  \n  output$sampPlot &lt;- renderPlot({\n    alldat &lt;- datasets() # get all pre-generated samples\n    if(whichsamp$i&gt;0){\n      dat &lt;- alldat$dat[1:whichsamp$i,,drop=FALSE] # grab just ones necessary for *this* plot\n    } else {\n      dat &lt;- alldat$dat[1:2,,drop=FALSE]\n    }\n    means &lt;- rowMeans(dat)\n    meanofmeans &lt;- mean(means)\n    sdofmeans &lt;- if (length(means) &gt; 1) {sd(means)} else {1} # JR: Perhaps inefficient? Using an if/else statement as otherwise we don\"t have an SD when N=1\n        # doing this necessitates changing sd() to stdev() throughout; is this how we usually compute SE? it's the SE of the simulated sampling distribution values...\n    \n    #FIXME: Skew and Kurtosis values are slighly off from what JASP gives\n    #CFF: could have a citation for where the equations come from\n    n &lt;- whichsamp$i\n    skewness &lt;- sum(((means-mean(means))/sd(means))^3) * (n / ((n - 1) * (n - 2))) # Sums the cubed standardized values, then multiplies them by [something]\n    skewnessSE &lt;- sqrt((6 * n * (n - 1) / ((n - 2) * (n + 1) * (n + 3))))\n    \n    #This section for debugging skewness/kurtosis\n    #print(means)\n    #print(meanofmeans)\n    #print(sum((means-meanofmeans)^2))\n    #print(sum((means-meanofmeans)^4))\n    #print(sum(((means-mean(means))/sd(means))^3))\n    \n    s2 &lt;- sum((means-meanofmeans)^2)\n    s4 &lt;- sum((means-meanofmeans)^4)\n    v &lt;- s2 / (n-1)\n    b &lt;- s4 / (v^2)\n    kurtosis &lt;- ((n * (n + 1)) / ((n - 1) * (n - 2) * (n - 3))) * b + ((-3 * (n - 1)^2) / ((n - 2) * (n - 3)))\n    kurtosisSE &lt;- 2 * skewnessSE * sqrt((n^2 - 1) / ((n - 3) * (n + 5)))\n    \n    lower &lt;- meanofmeans - 3*sdofmeans #JR: If we're changing the layout of the x-axis, won't need these anymore\n    upper &lt;- meanofmeans + 3*sdofmeans\n    \n    #binwidth= (upper-lower)/30\n    #binwidth= (base::max(means)-base::min(means))/input$bins\n    \n    plt &lt;- ggplot(data=as.data.frame(means), aes(x=means)) +\n      #Clears the y-axis label\n      ylab(\"Frequency\")+\n      #Sets the x axis ticks to cover the whole plot\n      #scale_x_continuous(limits=c(lower,upper),breaks= seq(round(lower),round(upper),by=1)) +\n      scale_x_continuous(limits=c(lower(),upper()),breaks= seq(round(lower()),round(upper()))) +\n      theme_classic()\n      \n    if(whichsamp$i&gt;0){\n      #plt &lt;- plt + geom_histogram(color=\"black\", fill=\"white\",binwidth = binwidth) +\n        plt &lt;- plt + geom_histogram(color=\"black\", fill=\"white\",bins = input$bins) +        \n        annotate(\"text\",x=Inf,y=Inf, label = paste0(\"Sampling Dist. Mean = \", round(meanofmeans,3)), vjust = 1, hjust = 1) +\n        annotate(\"text\",x=Inf,y=Inf, label = paste0(\"Total # of Samples = \", whichsamp$i), vjust = 3, hjust = 1) +\n        annotate(\"text\",x=Inf,y=Inf, label = paste0(\"Standard Deviation = \",round(sdofmeans,3)), vjust = 5, hjust = 1)\n        \n        if(input$overlay == TRUE) {\n          ggplot_build(plt)$data[[1]] -&gt; hist_layer\n          bin_width &lt;- hist_layer$x[2] - hist_layer$x[1]\n          plt &lt;- plt + stat_function(fun = function(x) dnorm(x, mean = meanofmeans, sd = sdofmeans) * whichsamp$i*bin_width)\n          #TODO: geom_histogram is defaulting to 1/30th of the data range; approximating this here, could use some refinement\n        } \n        \n        if(input$skew == TRUE) {\n          plt &lt;- plt + annotate(\"text\",x=Inf,y=Inf, label = paste0(\"Skewness = \", round(skewness,3),\" (SE=\",round(skewnessSE,3),\")\"), vjust = 7, hjust = 1) +\n            annotate(\"text\",x=Inf,y=Inf, label = paste0(\"Kurtosis = \", round(kurtosis,3),\" (SE=\",round(kurtosisSE,3),\")\"), vjust = 9, hjust = 1)\n        } \n    \n    }\n  plt\n    \n  }) #end output$sampPlot\n  \n  output$sampleTable &lt;- renderTable({\n    if(whichsamp$i&gt;0){\n      alldat &lt;- datasets() # get all pre-generated samples\n      dat &lt;- as.data.frame(alldat$dat[whichsamp$i-index$i,]) # grab just one of them for *this* sample plot\n      colname &lt;- paste0(\"Sample\", whichsamp$i-index$i)\n      colnames(dat) &lt;- colname\n      return(as.data.frame(dat))\n    } else {\n      return(data.frame())\n    }\n    }) #end output$sampleTable\n\n  output$sampleValues &lt;- renderPlot({\n    \n    alldat &lt;- datasets() # get all pre-generated samples\n    \n    if(whichsamp$i&gt;0){\n      dat &lt;- as.data.frame(alldat$dat[whichsamp$i-index$i,]) # grab just one of them for *this* sample plot\n      colname &lt;- paste0(\"Sample\", whichsamp$i-index$i)\n    } else {\n      dat &lt;- as.data.frame(alldat$dat[1,]) # grab just one of them for *this* sample plot\n      colname &lt;- \"dat\"\n    }\n    \n    colnames(dat) &lt;- colname\n    sample_mean &lt;- colMeans(dat)\n    sample_sd &lt;- sd(dat[,1]) #JR: Adding this in, may risk information overload though\n    sample_se &lt;- sample_sd/sqrt(obs()) #JR: Adding this in, may risk information overload though\n    \n    plt &lt;- ggplot(data=as.matrix(dat), aes(x=!!sym(colname))) +\n      xlab(NULL)\n      if(whichsamp$i&gt;0){\n      plt &lt;- plt + geom_dotplot(color=\"black\",method=\"histodot\", dotsize=.5) +\n        scale_y_continuous(name = \"\", breaks = NULL) +\n        annotate(\"text\",x=Inf,y=Inf, label = paste0(\"Sample Mean = \",round(sample_mean,3)), vjust = 1, hjust = 1) +# CFF changed sample_mean()\n        annotate(\"text\",x=Inf,y=Inf, label = paste0(\"Sample SD = \",round(sample_sd,3)), vjust = 3, hjust = 1) +\n        xlab(colname)\n         #JR: Added this in, may be information overload though\n      }\n    plt &lt;- plt +\n      #Clears the y-axis label\n      #ylab(\"Frequency\")+\n      #Sets the x axis ticks to cover the whole plot\n      scale_x_continuous(limits=c(lower(),upper()),breaks= seq(round(lower()),round(upper()))) +\n      #coord_cartesian(ratio=.5, expand=F) +\n      theme_classic()\n    \n    if(input$se == TRUE) {\n      plt + annotate(\"text\",x=Inf,y=Inf, label = paste0(\"Estimated Standard Error = \",round(sample_se,3)), vjust = 5, hjust = 1)\n    } else {\n    plt }\n  }) #\n  \n  output$sampleValuesTable &lt;- renderTable({\n    alldat &lt;- datasets() # get all pre-generated samples\n    if(whichsamp$i&gt;0){\n      dat &lt;- alldat$dat[1:whichsamp$i,,drop=FALSE] # grab just ones necessary for *this* plot\n      means &lt;- rowMeans(dat)\n      return(as.data.frame(means))\n    } else {\n      return(data.frame())\n    }\n    means &lt;- rowMeans(dat)\n    \n    \n  })\n} #end server()\n\n# Run the application \nshinyApp(ui = ui, server = server)"
  }
]